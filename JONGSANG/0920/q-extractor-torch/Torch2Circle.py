# Copyright (c) 2023 Samsung Electronics Co., Ltd. All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import shutil
import sys

import onnx
import onnx_tf
import tensorflow as tf
import torch
import torch.nn
import torch.quantization

sys.path.append('./include')
import subprocess

#  generated by pics.
#  TODO: we need to set pics dependency on cmakelist
from include.circle.Model import Model


class Torch2Circle:
    @staticmethod
    def toCircle(original_model: torch.nn.Module,
                 sample_input: torch.Tensor,
                 dir_path: str,
                 tflite2circle_path='tflite2circle',
                 clean_circle=True):
        tmp_path = os.path.join(dir_path, 'tmp')
        if not os.path.exists(tmp_path):
            os.makedirs(tmp_path, exist_ok=True)
        onnx_inferred_model = Torch2Circle.__toOnnx(original_model, sample_input,
                                                    tmp_path)
        tflite_path = Torch2Circle.__toTflite(onnx_inferred_model, tmp_path)
        circle_path = os.path.join(dir_path, 'input.circle')
        circle = Torch2Circle.__toCircle(tflite_path, circle_path, tflite2circle_path)
        shutil.rmtree(tmp_path)
        if clean_circle:
            os.remove(circle_path)

        return circle

    @staticmethod
    def __toOnnx(torch_model: torch.nn.Module, sample_input: torch.Tensor, dir_path: str):
        onnx_path = os.path.join(dir_path, "tmp.onnx")
        torch.onnx.export(torch_model, sample_input, onnx_path, opset_version=9)
        onnx_model = onnx.load(onnx_path)
        onnx.checker.check_model(onnx_model)
        inferred_model = onnx.shape_inference.infer_shapes(onnx_model)
        onnx.checker.check_model(inferred_model)
        return inferred_model

    @staticmethod
    def __toTflite(onnx_inferred_model: onnx.onnx_ONNX_REL_1_7_ml_pb2.ModelProto,
                   dir_path: str):
        tf_prep = onnx_tf.backend.prepare(onnx_inferred_model)
        tf_path = os.path.join(dir_path, 'tmp.tf')
        tf_prep.export_graph(path=tf_path)
        converter = tf.lite.TFLiteConverter.from_saved_model(tf_path)
        converter.allow_custom_ops = True
        converter.experimental_new_converter = True
        converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]
        tflite_model = converter.convert()
        tflite_path = os.path.join(dir_path, 'tmp.tflite')
        open(tflite_path, "wb").write(tflite_model)
        return tflite_path

    @staticmethod
    def __toCircle(tflite_path: str, circle_path: str, tflite2circle_path: str):
        try:
            subprocess.run([tflite2circle_path, tflite_path, circle_path], check=True)
        except Exception:
            print('Fail to convert to circle')
        buf = bytearray(open(circle_path, 'rb').read())
        return Model.GetRootAsModel(buf)
