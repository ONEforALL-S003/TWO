import os
import shutil
import sys

import torch
import torch.nn
import torch.quantization
import numpy as np
import collections
import json
import onnx
import onnx_tf
import tensorflow as tf
sys.path.append('./include')
import subprocess

#  generated by pics.
#  we need to set dependency on cmakelist
import flatbuffers
from include.circle.Model import Model
from include.circle.SubGraph import SubGraph


class Torch2CircleMapper:
    @staticmethod
    def permute(tensor: torch.Tensor) -> torch.Tensor:
        dim = len(tensor.shape)
        if dim == 4:  # NCHW to NHWC
            tensor = tensor.permute(0, 2, 3, 1)
        return tensor
    

    def __init__(self, dir_path: str):
        self.__dir_path = dir_path
        
        self.__mapping = None
        self.__reverse_mapping = None
        self.__network_input = None
        self.__network_output = None


    def __torch2circle(self, original_model: torch.nn.Module, sample_input: torch.Tensor) -> Model:
        dir_path = os.path.join(self.__dir_path, "tmp")
        if not os.path.exists(dir_path):
            os.makedirs(dir_path, exist_ok=True)

        onnx_path = os.path.join(dir_path, "tmp.onnx")
        torch.onnx.export(original_model, sample_input, onnx_path, opset_version=9)
        onnx_model = onnx.load(onnx_path)
        onnx.checker.check_model(onnx_model)
        inferred_model = onnx.shape_inference.infer_shapes(onnx_model)
        onnx.checker.check_model(inferred_model)
        onnx.save(inferred_model, onnx_path)
        tf_prep = onnx_tf.backend.prepare(inferred_model)
        tf_path = os.path.join(dir_path, 'tmp.tf')
        tf_prep.export_graph(path=tf_path)
        graph_def = tf_prep.tf_module.graph_def
        converter = tf.lite.TFLiteConverter.from_saved_model(tf_path)
        converter.allow_custom_ops = True
        converter.experimental_new_converter = True
        converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]
        tflite_model = converter.convert()
        tflite_path = os.path.join(dir_path, 'tmp.tflite')
        open(tflite_path, "wb").write(tflite_model)
        circle_path = os.path.join(self.__dir_path, 'input.circle')
        try:
            #  TODO: Need to set relative path of build of tflite2circle or get path by program argument
            subprocess.run(['./tflite2circle', tflite_path, circle_path], check=True)
        except Exception:
            print('Fail to convert to circle')
        buf = bytearray(open(circle_path, 'rb').read())
        return Model.GetRootAsModel(buf)


    def __circle_subgraph_mapping_traverse(self, circle: Model, graph: SubGraph):
        mapping, reverse_mapping = self.__mapping, self.__reverse_mapping
        op_mapping = {}

        for idx in range(graph.InputsLength()):
            input_tensor = graph.Tensors(graph.Inputs(idx))
            self.__network_input.append(input_tensor)

        for idx in range(graph.OutputsLength()):
            output_tensor = graph.Tensors(graph.Outputs(idx))
            self.__network_output.append(output_tensor)

        for idx in range(graph.TensorsLength()):
            tensor = graph.Tensors(idx)
            name = tensor.Name().decode('utf-8')
            shape = tensor.ShapeAsNumpy()
            if shape.size == 0:
                continue
            buffer = circle.Buffers(tensor.Buffer()).DataAsNumpy()
            if type(buffer) is not np.ndarray or buffer.size == 0:
                continue
            key = hash(buffer.tobytes())

            if key in reverse_mapping:
                origin_name = reverse_mapping[key]
                op_name = origin_name[:origin_name.rfind(".")]
                mapping[origin_name] = name
                if op_name not in op_mapping:
                    op_mapping[op_name] = set()
                op_mapping[op_name].add(idx)

        # approximately it takes O(N^2)
        # we need to think to it better way or not
        for i in range(graph.OperatorsLength()):
            operator = graph.Operators(i)
            input_set = set(operator.InputsAsNumpy().tolist())

            for op_name, op_input in op_mapping.items():
                need_break = False
                if input_set.issuperset(op_input):
                    need_break = True
                    input_set = input_set - op_input
                    for tensor_idx in input_set:
                        tensor = graph.Tensors(tensor_idx)
                        tensor_name = tensor.Name().decode('utf-8')
                        mapping[op_name] = tensor_name
                if need_break:
                    break


    def get_mapped_dict(self, original_model :torch.nn.Module, sample_input: torch.Tensor) -> dict:
        if self.__mapping is not None or self.__reverse_mapping is not None:
            return

        self.__mapping = {}
        self.__reverse_mapping = reverse_mapping = {}

        if original_model is None or not isinstance(original_model, torch.nn.Module):
            raise Exception("There is no Pytorch Model for mapping")
        if sample_input is None or not isinstance(sample_input, torch.Tensor):
            raise Exception("Please give sample input to convert model")
        params = original_model.named_parameters()

        for name, param in params:
            tensor = param.data
            tensor = self.permute(tensor)
            key = hash(tensor.numpy().tobytes())
            reverse_mapping[key] = name

        circle = self.__torch2circle(original_model, sample_input)
        
        self.__network_input = []
        self.__network_output = []
        for idx in range(circle.SubgraphsLength()):
            self.__circle_subgraph_mapping_traverse(circle, circle.Subgraphs(idx))
        shutil.rmtree(os.path.join(self.__dir_path, "tmp"))

        input_list = []
        output_list = []
        for name, mod in original_model.named_modules():
            if name == '':  # it's just model itself
                continue
            if isinstance(mod, torch.quantization.QuantStub):
                input_list.append(name)
            elif isinstance(mod, torch.quantization.DeQuantStub):
                output_list.append(name)

        if len(input_list) == 1 and len(self.__network_input) == 1:
            self.__mapping[input_list[0]] = self.__network_input[0].Name().decode('utf-8')
        else:
            print("There are more than one input of Network. Please map it manually")

        if len(output_list) == 1 and len(self.__network_output) == 1:
            # self.__mapping[output_list[0]] = self.__network_output[0].Name().decode('utf-8')
            # TODO: find previous operator of output and get quantization parameter
            pass
        else:
            print("There are more than one output of Network. Please map it manually")

        return self.__mapping